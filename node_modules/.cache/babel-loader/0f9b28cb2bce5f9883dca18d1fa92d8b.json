{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _defineProperty from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Constants from 'expo-constants';\nimport qs from 'qs';\nimport { openAuthSessionAsync, dismissAuthSession } from 'expo-web-browser';\nimport Linking from './Linking/Linking';\nvar BASE_URL = \"https://auth.expo.io\";\nvar _authLock = false;\n\nfunction startAsync(_x) {\n  return _startAsync.apply(this, arguments);\n}\n\nfunction _startAsync() {\n  _startAsync = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(options) {\n    var returnUrl, authUrl, startUrl, result, _parseUrl, params, errorCode;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            returnUrl = options.returnUrl || getDefaultReturnUrl();\n            authUrl = options.authUrl;\n            startUrl = getStartUrl(authUrl, returnUrl); // Prevent accidentally starting to an empty url\n\n            if (authUrl) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');\n\n          case 5:\n            if (!_authLock) {\n              _context.next = 8;\n              break;\n            }\n\n            if (__DEV__) {\n              console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');\n            }\n\n            return _context.abrupt(\"return\", {\n              type: 'locked'\n            });\n\n          case 8:\n            // About to start session, set lock\n            _authLock = true;\n            _context.prev = 9;\n            _context.next = 12;\n            return _openWebBrowserAsync(startUrl, returnUrl);\n\n          case 12:\n            result = _context.sent;\n\n          case 13:\n            _context.prev = 13;\n            // WebBrowser session complete, unset lock\n            _authLock = false;\n            return _context.finish(13);\n\n          case 16:\n            if (result) {\n              _context.next = 18;\n              break;\n            }\n\n            throw new Error('Unexpected missing AuthSession result');\n\n          case 18:\n            if (result.url) {\n              _context.next = 24;\n              break;\n            }\n\n            if (!result.type) {\n              _context.next = 23;\n              break;\n            }\n\n            return _context.abrupt(\"return\", result);\n\n          case 23:\n            throw new Error('Unexpected AuthSession result with missing type');\n\n          case 24:\n            _parseUrl = parseUrl(result.url), params = _parseUrl.params, errorCode = _parseUrl.errorCode;\n            return _context.abrupt(\"return\", {\n              type: errorCode ? 'error' : 'success',\n              params: params,\n              errorCode: errorCode,\n              url: result.url\n            });\n\n          case 26:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[9,, 13, 16]]);\n  }));\n  return _startAsync.apply(this, arguments);\n}\n\nfunction dismiss() {\n  dismissAuthSession();\n}\n\nfunction _openWebBrowserAsync(_x2, _x3) {\n  return _openWebBrowserAsync2.apply(this, arguments);\n}\n\nfunction _openWebBrowserAsync2() {\n  _openWebBrowserAsync2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(startUrl, returnUrl) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return openAuthSessionAsync(startUrl, returnUrl);\n\n          case 2:\n            result = _context2.sent;\n\n            if (!(result.type === 'cancel' || result.type === 'dismiss')) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", {\n              type: result.type\n            });\n\n          case 5:\n            return _context2.abrupt(\"return\", result);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _openWebBrowserAsync2.apply(this, arguments);\n}\n\nfunction getStartUrl(authUrl, returnUrl) {\n  var queryString = qs.stringify({\n    authUrl: authUrl,\n    returnUrl: returnUrl\n  });\n  return \"\".concat(getRedirectUrl(), \"/start?\").concat(queryString);\n}\n\nfunction getRedirectUrl() {\n  var redirectUrl = \"\".concat(BASE_URL, \"/\").concat(Constants.manifest.id);\n\n  if (__DEV__) {\n    _warnIfAnonymous(Constants.manifest.id, redirectUrl);\n  }\n\n  return redirectUrl;\n}\n\nfunction getDefaultReturnUrl() {\n  return Linking.makeUrl('expo-auth-session');\n}\n\nfunction parseUrl(url) {\n  var parts = url.split('#');\n  var hash = parts[1];\n  var partsWithoutHash = parts[0].split('?');\n  var queryString = partsWithoutHash[partsWithoutHash.length - 1]; // Get query string (?hello=world)\n\n  var parsedSearch = qs.parse(queryString); // Pull errorCode off of params\n\n  var errorCode = parsedSearch.errorCode;\n  delete parsedSearch.errorCode; // Get hash (#abc=example)\n\n  var parsedHash = {};\n\n  if (parts[1]) {\n    parsedHash = qs.parse(hash);\n  } // Merge search and hash\n\n\n  var params = _objectSpread({}, parsedSearch, {}, parsedHash);\n\n  return {\n    errorCode: errorCode,\n    params: params\n  };\n}\n\nfunction _warnIfAnonymous(id, url) {\n  if (id.startsWith('@anonymous/')) {\n    console.warn(\"You are not currently signed in to Expo on your development machine. As a result, the redirect URL for AuthSession will be \\\"\".concat(url, \"\\\". If you are using an OAuth provider that requires whitelisting redirect URLs, we recommend that you do not whitelist this URL -- instead, you should sign in to Expo to acquired a unique redirect URL. Additionally, if you do decide to publish this app using Expo, you will need to register an account to do it.\"));\n  }\n}\n\nexport default {\n  dismiss: dismiss,\n  getRedirectUrl: getRedirectUrl,\n  getStartUrl: getStartUrl,\n  getDefaultReturnUrl: getDefaultReturnUrl,\n\n  get getRedirectUri() {\n    console.warn('Use AuthSession.getRedirectUrl rather than AuthSession.getRedirectUri (Url instead of Uri)');\n    return getRedirectUrl;\n  },\n\n  startAsync: startAsync\n};","map":null,"metadata":{},"sourceType":"module"}