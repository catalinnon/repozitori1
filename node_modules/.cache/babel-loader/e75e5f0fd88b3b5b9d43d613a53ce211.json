{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Constants from 'expo-constants';\nimport qs from 'qs';\nimport Linking from './LinkingModule';\nvar manifest = Constants.manifest;\nvar USES_CUSTOM_SCHEME = Constants.appOwnership === 'standalone' && manifest.scheme;\nvar HOST_URI = manifest.hostUri;\n\nif (!HOST_URI && !USES_CUSTOM_SCHEME) {\n  // we're probably not using up-to-date xdl, so just fake it for now\n  // we have to remove the /--/ on the end since this will be inserted again later\n  HOST_URI = _removeScheme(Constants.linkingUri).replace(/\\/--($|\\/.*$)/, '');\n}\n\nvar IS_EXPO_HOSTED = HOST_URI && (/^(.*\\.)?(expo\\.io|exp\\.host|exp\\.direct|expo\\.test)(:.*)?(\\/.*)?$/.test(HOST_URI) || manifest.developer);\n\nfunction _removeScheme(url) {\n  return url.replace(/^[a-zA-Z0-9+.-]+:\\/\\//, '');\n}\n\nfunction _removePort(url) {\n  return url.replace(/(?=([a-zA-Z0-9+.-]+:\\/\\/)?[^/]):\\d+/, '');\n}\n\nfunction _removeLeadingSlash(url) {\n  return url.replace(/^\\//, '');\n}\n\nfunction _removeTrailingSlash(url) {\n  return url.replace(/\\/$/, '');\n}\n\nfunction _removeTrailingSlashAndQueryString(url) {\n  return url.replace(/\\/?\\?.*$/, '');\n}\n\nfunction makeUrl() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var scheme = 'exp';\n\n  if (Constants.appOwnership === 'standalone') {\n    scheme = manifest.scheme || manifest.detach && manifest.detach.scheme;\n  }\n\n  if (!scheme) {\n    throw new Error('Cannot make a deep link into a standalone app with no custom scheme defined');\n  }\n\n  var hostUri = HOST_URI || '';\n\n  if (USES_CUSTOM_SCHEME && IS_EXPO_HOSTED) {\n    hostUri = '';\n  }\n\n  if (path) {\n    if (IS_EXPO_HOSTED && hostUri) {\n      path = \"/--/\".concat(_removeLeadingSlash(path));\n    }\n\n    if (!path.startsWith('/') && hostUri) {\n      path = \"/\".concat(path);\n    } else if (path.startsWith('/') && !hostUri) {\n      path = path.substr(1);\n    }\n  } else {\n    path = '';\n  } // merge user-provided query params with any that were already in the hostUri\n  // e.g. release-channel\n\n\n  var queryString = '';\n  var queryStringMatchResult = hostUri.match(/(.*)\\?(.+)/);\n\n  if (queryStringMatchResult) {\n    hostUri = queryStringMatchResult[1];\n    queryString = queryStringMatchResult[2];\n    var paramsFromHostUri = {};\n\n    try {\n      var parsedParams = qs.parse(queryString);\n\n      if (typeof parsedParams === 'object') {\n        paramsFromHostUri = parsedParams;\n      }\n    } catch (e) {}\n\n    queryParams = _objectSpread({}, queryParams, {}, paramsFromHostUri);\n  }\n\n  queryString = qs.stringify(queryParams);\n\n  if (queryString) {\n    queryString = \"?\".concat(queryString);\n  }\n\n  hostUri = _removeTrailingSlash(hostUri);\n  return encodeURI(\"\".concat(scheme, \"://\").concat(hostUri).concat(path).concat(queryString));\n}\n\nfunction parse(url) {\n  if (!url) {\n    throw new Error('parse cannot be called with a null value');\n  } // iOS client sometimes strips out the port from the initial URL\n  // even when it's included in the hostUri.\n  // This function should be able to handle both cases, so we strip off the port\n  // both here and from the hostUri.\n\n\n  var decodedUrl = _removePort(decodeURI(url));\n\n  var path;\n  var queryParams = {};\n  var queryStringMatchResult = decodedUrl.match(/(.*)\\?(.+)/);\n\n  if (queryStringMatchResult) {\n    decodedUrl = queryStringMatchResult[1];\n    queryParams = qs.parse(queryStringMatchResult[2]);\n  } // strip off the hostUri from the host and path\n\n\n  var hostUri = HOST_URI || '';\n\n  var hostUriStripped = _removePort(_removeTrailingSlashAndQueryString(hostUri));\n\n  if (hostUriStripped && decodedUrl.indexOf(hostUriStripped) > -1) {\n    path = decodedUrl.substr(decodedUrl.indexOf(hostUriStripped) + hostUriStripped.length);\n  } else {\n    path = _removeScheme(decodedUrl);\n  }\n\n  path = _removeLeadingSlash(path);\n\n  if (IS_EXPO_HOSTED && !USES_CUSTOM_SCHEME && path.startsWith('--/')) {\n    path = path.substr(3);\n  } else if (path.indexOf('+') > -1) {\n    path = path.substr(path.indexOf('+') + 1);\n  }\n\n  return {\n    path: path,\n    queryParams: queryParams\n  };\n}\n\nfunction parseInitialURLAsync() {\n  return _parseInitialURLAsync.apply(this, arguments);\n} // @ts-ignore fix this...\n\n\nfunction _parseInitialURLAsync() {\n  _parseInitialURLAsync = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var initialUrl;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Linking.getInitialURL();\n\n          case 2:\n            initialUrl = _context.sent;\n\n            if (initialUrl) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", {\n              path: null,\n              queryParams: null\n            });\n\n          case 5:\n            return _context.abrupt(\"return\", parse(initialUrl));\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseInitialURLAsync.apply(this, arguments);\n}\n\nvar newLinking = new Linking.constructor();\nnewLinking.makeUrl = makeUrl;\nnewLinking.parse = parse;\nnewLinking.parseInitialURLAsync = parseInitialURLAsync;\nexport default newLinking;","map":null,"metadata":{},"sourceType":"module"}