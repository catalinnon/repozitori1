{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Readable } from 'stream';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n/**\r\n * Handles Readable streams requests as concatenation through data handling as\r\n * well adding tags it each begin, end and between of the streams\r\n */\n\n\nvar SandwichStream =\n/*#__PURE__*/\nfunction (_Readable) {\n  _inherits(SandwichStream, _Readable);\n\n  /**\r\n   * Initiates the SandwichStream, you can consider it also passing\r\n   * ReadableOptions to it\r\n   *\r\n   * @param head Pushes this content before all other content\r\n   * @param tail Pushes this content after all other data has been pushed\r\n   * @param separator Pushes this content between each stream\r\n   * @param remaining The other kind of options to be passed to Readable\r\n   * @example\r\n   * const ss = new SandwichStream({\r\n   *     head: 'This at the top\\n',\r\n   *     tail: '\\nThis at the bottom',\r\n   *     separator: '\\n --- \\n'\r\n   * });\r\n   */\n  function SandwichStream(_a) {\n    var _this;\n\n    _classCallCheck(this, SandwichStream);\n\n    var head = _a.head,\n        tail = _a.tail,\n        separator = _a.separator,\n        remaining = __rest(_a, [\"head\", \"tail\", \"separator\"]);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SandwichStream).call(this, remaining));\n    _this.streamsActive = false;\n    _this.streams = [];\n    _this.newStreams = [];\n    _this.currentStream = null;\n    _this.head = null !== head && undefined !== head ? head : null;\n    _this.tail = null !== tail && undefined !== tail ? tail : null;\n    _this.separator = null !== separator && undefined !== separator ? separator : null;\n    return _this;\n  }\n  /**\r\n   * Add a new Readable stream in the queue\r\n   *\r\n   * @param newStream The Readable stream\r\n   * @example\r\n   * sandwichStream.add(streamOne);\r\n   * sandwichStream.add(streamTwo);\r\n   * sandwichStream.add(streamThree);\r\n   * @throws An Error in case that this request was not accepted\r\n   * @returns This instance of Sandwich Stream\r\n   */\n\n\n  _createClass(SandwichStream, [{\n    key: \"add\",\n    value: function add(newStream) {\n      if (false === this.streamsActive) {\n        this.streams.push(newStream);\n        newStream.on('error', this.subStreamOnError.bind(this));\n      } else {\n        this.newStreams.push(newStream);\n      }\n\n      return this;\n    }\n    /**\r\n     * Works in a similar way from the Readable read, only that this one checks\r\n     * for whether or not a stream is already being handled\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      if (false === this.streamsActive) {\n        this.streamsActive = true;\n        this.pushHead();\n        this.streamNextStream();\n      }\n    }\n    /**\r\n     * Binds an error thrown from one of the streams being handled\r\n     *\r\n     * @param err Error to be bind\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"subStreamOnError\",\n    value: function subStreamOnError(err) {\n      this.emit('error', err);\n    }\n    /**\r\n     * Fetches the next stream to be handled\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"streamNextStream\",\n    value: function streamNextStream() {\n      if (true === this.nextStream()) {\n        this.bindCurrentStreamEvents();\n      } else {\n        this.pushTail();\n        this.push(null);\n      }\n    }\n    /**\r\n     * Verifies whether or not the stream queue has ended\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"nextStream\",\n    value: function nextStream() {\n      var tmp = this.streams.shift();\n      this.currentStream = undefined !== tmp ? tmp : null;\n      return null !== this.currentStream;\n    }\n    /**\r\n     * Once the current stream starts to pass their data, this handles it in a\r\n     * less complicated way\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"bindCurrentStreamEvents\",\n    value: function bindCurrentStreamEvents() {\n      this.currentStream.on('readable', this.currentStreamOnReadable.bind(this));\n      this.currentStream.on('end', this.currentStreamOnEnd.bind(this));\n    }\n    /**\r\n     * Handles the data from a current stream once they are being streamed\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"currentStreamOnReadable\",\n    value: function currentStreamOnReadable() {\n      var tmp = this.currentStream.read();\n      var data = undefined !== tmp && null !== tmp ? tmp : '';\n      this.push(data);\n    }\n    /**\r\n     * Handles the tagging once a stream is finished\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"currentStreamOnEnd\",\n    value: function currentStreamOnEnd() {\n      this.pushSeparator();\n      this.streams.concat(this.newStreams);\n      this.newStreams = [];\n      this.streamNextStream();\n    }\n    /**\r\n     * Adds the head tag to the Sandwich Stream\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"pushHead\",\n    value: function pushHead() {\n      if (null !== this.head) {\n        this.push(this.head);\n      }\n    }\n    /**\r\n     * Adds the separator tag to the Sandwich Stream\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"pushSeparator\",\n    value: function pushSeparator() {\n      if (0 < this.streams.length && null !== this.separator) {\n        this.push(this.separator);\n      }\n    }\n    /**\r\n     * Adds the tail tag to the Sandwich Stream\r\n     * @returns This instance of Sandwich Stream\r\n     */\n\n  }, {\n    key: \"pushTail\",\n    value: function pushTail() {\n      if (null !== this.tail) {\n        this.push(this.tail);\n      }\n    }\n  }]);\n\n  return SandwichStream;\n}(Readable);\n\nexport default SandwichStream;\nexport { SandwichStream };","map":null,"metadata":{},"sourceType":"module"}