{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"C:\\\\Users\\\\Admin\\\\Desktop\\\\\\u041F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B\\\\NodeJS\\\\TestVKMiniApp\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport { AsyncStorage, Platform } from 'react-native';\nimport { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport ExponentNotifications from './ExponentNotifications';\n\nvar _emitter;\n\nvar _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n  /* Don't mutate the original notification */\n\n\n  notification = _objectSpread({}, notification);\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {// It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  } // Delete any Android properties on iOS and merge the iOS properties on root notification object\n\n\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  } // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n\n\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(!!notification.title && !!notification.body, 'Local notifications on iOS require both a title and a body');\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nvar ASYNC_STORAGE_PREFIX = '__expo_internal_channel_'; // TODO: remove this before releasing\n// this will always be `true` for SDK 28+\n\nvar IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nfunction _legacyReadChannel(_x) {\n  return _legacyReadChannel2.apply(this, arguments);\n}\n\nfunction _legacyReadChannel2() {\n  _legacyReadChannel2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee10(id) {\n    var channelString;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.prev = 0;\n            _context10.next = 3;\n            return AsyncStorage.getItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n\n          case 3:\n            channelString = _context10.sent;\n\n            if (!channelString) {\n              _context10.next = 6;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", JSON.parse(channelString));\n\n          case 6:\n            _context10.next = 10;\n            break;\n\n          case 8:\n            _context10.prev = 8;\n            _context10.t0 = _context10[\"catch\"](0);\n\n          case 10:\n            return _context10.abrupt(\"return\", null);\n\n          case 11:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[0, 8]]);\n  }));\n  return _legacyReadChannel2.apply(this, arguments);\n}\n\nfunction _legacyDeleteChannel(id) {\n  return AsyncStorage.removeItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear =\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(callback) {\n      var keys, filteredKeys;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return AsyncStorage.getAllKeys();\n\n            case 3:\n              keys = _context.sent;\n\n              if (!(keys && keys.length)) {\n                _context.next = 8;\n                break;\n              }\n\n              filteredKeys = keys.filter(function (key) {\n                return !key.startsWith(ASYNC_STORAGE_PREFIX);\n              });\n              _context.next = 8;\n              return AsyncStorage.multiRemove(filteredKeys);\n\n            case 8:\n              callback && callback();\n              _context.next = 15;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](0);\n              callback && callback(_context.t0);\n              throw _context.t0;\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 11]]);\n    }));\n\n    return function (_x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n} // This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\n\n\nfunction _legacySaveChannel(id, channel) {\n  return AsyncStorage.setItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id), JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification: function _setInitialNotification(notification) {\n    _initialNotification = notification;\n  },\n  // User passes set of actions titles.\n  createCategoryAsync: function createCategoryAsync(categoryId, actions) {\n    return ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n  deleteCategoryAsync: function deleteCategoryAsync(categoryId) {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync: function getExpoPushTokenAsync() {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n\n    if (!Constants.isDevice) {\n      throw new Error(\"Must be on a physical device to get an Expo Push Token\");\n    }\n\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n  getDevicePushTokenAsync: function getDevicePushTokenAsync(config) {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n  createChannelAndroidAsync: function createChannelAndroidAsync(id, channel) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"createChannelAndroidAsync(...) has no effect on \".concat(Platform.OS));\n      return Promise.resolve();\n    } // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n\n\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n\n    return ExponentNotifications.createChannel(id, channel);\n  },\n  deleteChannelAndroidAsync: function deleteChannelAndroidAsync(id) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"deleteChannelAndroidAsync(...) has no effect on \".concat(Platform.OS));\n      return Promise.resolve();\n    } // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n\n\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  presentLocalNotificationAsync: function () {\n    var _presentLocalNotificationAsync = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(notification) {\n      var nativeNotification, _channel;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _validateNotification(notification);\n\n              nativeNotification = _processNotification(notification);\n\n              if (!(Platform.OS !== 'android')) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 5;\n              return ExponentNotifications.presentLocalNotification(nativeNotification);\n\n            case 5:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 8:\n              if (!nativeNotification.channelId) {\n                _context2.next = 12;\n                break;\n              }\n\n              _context2.next = 11;\n              return _legacyReadChannel(nativeNotification.channelId);\n\n            case 11:\n              _channel = _context2.sent;\n\n            case 12:\n              if (!IS_USING_NEW_BINARY) {\n                _context2.next = 17;\n                break;\n              }\n\n              // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n              _legacyDeleteChannel(nativeNotification.channelId);\n\n              return _context2.abrupt(\"return\", ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification, _channel));\n\n            case 17:\n              // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n              // channel does not actually exist, so add its settings to the individual notification\n              if (_channel) {\n                nativeNotification.sound = _channel.sound;\n                nativeNotification.priority = _channel.priority;\n                nativeNotification.vibrate = _channel.vibrate;\n              }\n\n              return _context2.abrupt(\"return\", ExponentNotifications.presentLocalNotification(nativeNotification));\n\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function presentLocalNotificationAsync(_x3) {\n      return _presentLocalNotificationAsync.apply(this, arguments);\n    }\n\n    return presentLocalNotificationAsync;\n  }(),\n\n  /* Schedule a notification at a later date */\n  scheduleLocalNotificationAsync: function () {\n    var _scheduleLocalNotificationAsync = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(notification) {\n      var options,\n          now,\n          nativeNotification,\n          timeAsDateObj,\n          validOptions,\n          _channel,\n          _args3 = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n              // set now at the beginning of the method, to prevent potential weird warnings when we validate\n              // options.time later on\n              now = Date.now(); // Validate and process the notification data\n\n              _validateNotification(notification);\n\n              nativeNotification = _processNotification(notification); // Validate `options.time`\n\n              if (!options.time) {\n                _context3.next = 11;\n                break;\n              }\n\n              timeAsDateObj = null;\n\n              if (options.time && typeof options.time === 'number') {\n                timeAsDateObj = new Date(options.time);\n\n                if (timeAsDateObj.toString() === 'Invalid Date') {\n                  timeAsDateObj = null;\n                }\n              } else if (options.time && options.time instanceof Date) {\n                timeAsDateObj = options.time;\n              } // If we couldn't convert properly, throw an error\n\n\n              if (timeAsDateObj) {\n                _context3.next = 9;\n                break;\n              }\n\n              throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");\n\n            case 9:\n              // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n              // accidently pass seconds instead of ms), display a warning.\n              if (timeAsDateObj.getTime() < now) {\n                console.warn(\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");\n              }\n\n              options = _objectSpread({}, options, {\n                time: timeAsDateObj.getTime()\n              });\n\n            case 11:\n              if (!(options.intervalMs != null && options.repeat != null)) {\n                _context3.next = 13;\n                break;\n              }\n\n              throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");\n\n            case 13:\n              if (!(options.repeat != null)) {\n                _context3.next = 17;\n                break;\n              }\n\n              validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n\n              if (validOptions.has(options.repeat)) {\n                _context3.next = 17;\n                break;\n              }\n\n              throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");\n\n            case 17:\n              if (!(options.intervalMs != null)) {\n                _context3.next = 22;\n                break;\n              }\n\n              if (!(Platform.OS === 'ios')) {\n                _context3.next = 20;\n                break;\n              }\n\n              throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");\n\n            case 20:\n              if (!(options.intervalMs <= 0 || !Number.isInteger(options.intervalMs))) {\n                _context3.next = 22;\n                break;\n              }\n\n              throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");\n\n            case 22:\n              if (!(Platform.OS !== 'android')) {\n                _context3.next = 29;\n                break;\n              }\n\n              if (!options.repeat) {\n                _context3.next = 26;\n                break;\n              }\n\n              console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n              return _context3.abrupt(\"return\", ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options));\n\n            case 26:\n              return _context3.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n\n            case 29:\n              if (!nativeNotification.channelId) {\n                _context3.next = 33;\n                break;\n              }\n\n              _context3.next = 32;\n              return _legacyReadChannel(nativeNotification.channelId);\n\n            case 32:\n              _channel = _context3.sent;\n\n            case 33:\n              if (!IS_USING_NEW_BINARY) {\n                _context3.next = 38;\n                break;\n              }\n\n              // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n              _legacyDeleteChannel(nativeNotification.channelId);\n\n              return _context3.abrupt(\"return\", ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification, options, _channel));\n\n            case 38:\n              // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n              // channel does not actually exist, so add its settings to the individual notification\n              if (_channel) {\n                nativeNotification.sound = _channel.sound;\n                nativeNotification.priority = _channel.priority;\n                nativeNotification.vibrate = _channel.vibrate;\n              }\n\n              return _context3.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n\n            case 40:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    function scheduleLocalNotificationAsync(_x4) {\n      return _scheduleLocalNotificationAsync.apply(this, arguments);\n    }\n\n    return scheduleLocalNotificationAsync;\n  }(),\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  dismissNotificationAsync: function () {\n    var _dismissNotificationAsync = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4(notificationId) {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (ExponentNotifications.dismissNotification) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n\n            case 2:\n              _context4.next = 4;\n              return ExponentNotifications.dismissNotification(notificationId);\n\n            case 4:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    function dismissNotificationAsync(_x5) {\n      return _dismissNotificationAsync.apply(this, arguments);\n    }\n\n    return dismissNotificationAsync;\n  }(),\n\n  /* Dismiss all currently shown notifications (Android only) */\n  dismissAllNotificationsAsync: function () {\n    var _dismissAllNotificationsAsync = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5() {\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (ExponentNotifications.dismissAllNotifications) {\n                _context5.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n\n            case 2:\n              _context5.next = 4;\n              return ExponentNotifications.dismissAllNotifications();\n\n            case 4:\n              return _context5.abrupt(\"return\", _context5.sent);\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    function dismissAllNotificationsAsync() {\n      return _dismissAllNotificationsAsync.apply(this, arguments);\n    }\n\n    return dismissAllNotificationsAsync;\n  }(),\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync: function cancelScheduledNotificationAsync(notificationId) {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync: function cancelAllScheduledNotificationsAsync() {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  /* Primary public api */\n  addListener: function addListener(listener) {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      var initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(function () {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n  getBadgeNumberAsync: function () {\n    var _getBadgeNumberAsync = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee6() {\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (ExponentNotifications.getBadgeNumberAsync) {\n                _context6.next = 2;\n                break;\n              }\n\n              return _context6.abrupt(\"return\", 0);\n\n            case 2:\n              return _context6.abrupt(\"return\", ExponentNotifications.getBadgeNumberAsync());\n\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    function getBadgeNumberAsync() {\n      return _getBadgeNumberAsync.apply(this, arguments);\n    }\n\n    return getBadgeNumberAsync;\n  }(),\n  setBadgeNumberAsync: function () {\n    var _setBadgeNumberAsync = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee7(number) {\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (ExponentNotifications.setBadgeNumberAsync) {\n                _context7.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n\n            case 2:\n              return _context7.abrupt(\"return\", ExponentNotifications.setBadgeNumberAsync(number));\n\n            case 3:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    function setBadgeNumberAsync(_x6) {\n      return _setBadgeNumberAsync.apply(this, arguments);\n    }\n\n    return setBadgeNumberAsync;\n  }(),\n  scheduleNotificationWithCalendarAsync: function () {\n    var _scheduleNotificationWithCalendarAsync = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee8(notification) {\n      var options,\n          areOptionsValid,\n          _args8 = arguments;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n              areOptionsValid = (options.month == null || isInRangeInclusive(options.month, 1, 12)) && (options.day == null || isInRangeInclusive(options.day, 1, 31)) && (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) && (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) && (options.second == null || isInRangeInclusive(options.second, 0, 59)) && (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) && (options.weekDay == null || options.day == null);\n\n              if (areOptionsValid) {\n                _context8.next = 4;\n                break;\n              }\n\n              throw new CodedError('WRONG_OPTIONS', 'Options in scheduleNotificationWithCalendarAsync call were incorrect!');\n\n            case 4:\n              return _context8.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithCalendar(notification, options));\n\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n\n    function scheduleNotificationWithCalendarAsync(_x7) {\n      return _scheduleNotificationWithCalendarAsync.apply(this, arguments);\n    }\n\n    return scheduleNotificationWithCalendarAsync;\n  }(),\n  scheduleNotificationWithTimerAsync: function () {\n    var _scheduleNotificationWithTimerAsync = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee9(notification, options) {\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              if (!(options.interval < 1)) {\n                _context9.next = 2;\n                break;\n              }\n\n              throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n\n            case 2:\n              return _context9.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithTimer(notification, options));\n\n            case 3:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9);\n    }));\n\n    function scheduleNotificationWithTimerAsync(_x8, _x9) {\n      return _scheduleNotificationWithTimerAsync.apply(this, arguments);\n    }\n\n    return scheduleNotificationWithTimerAsync;\n  }()\n};\n\nfunction isInRangeInclusive(variable, min, max) {\n  return variable >= min && variable <= max;\n}","map":null,"metadata":{},"sourceType":"module"}